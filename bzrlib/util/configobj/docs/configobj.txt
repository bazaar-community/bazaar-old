==================================
 Reading and Writing Config Files
==================================

----------------------------------------
 ConfigObj 4 Introduction and Reference
----------------------------------------

:Authors: Michael Foord, Nicola Larosa
:Version: ConfigObj 4.0.0
:Date: 2005/10/17
:Homepage: `ConfigObj Homepage`_
:Sourceforge: Sourceforge_
:License: `BSD License`_
:Support: `Mailing List`_

.. _Mailing List: http://lists.sourceforge.net/lists/listinfo/configobj-develop

.. meta::
   :description: ConfigObj - a Python module for easy reading and writing of 
                 config files.
   :keywords: python, script, module, config, configuration, data, persistence,
              developer, configparser

.. contents:: ConfigObj Manual
.. sectnum::

Introduction
============

**ConfigObj** is a simple but powerful config file reader and writer: an *ini
file round tripper*. Its main feature is that it is very easy to use, with a
straightforward programmer's interface and a simple syntax for config files.
It has lots of other features though :

* Nested sections (subsections), to any level
* List values
* Multiple line values
* String interpolation (substitution)
* Integrated with a powerful validation system

    * including automatic type checking/conversion
    * repeated sections
    * and allowing default values

* All comments in the file are preserved
* The order of keys/sections is preserved
* No external dependencies

ConfigObj 4 is a complete rewrite of ConfigObj. A great deal has been
simplified and improved [#]_ since ConfigObj 3. If you have used ConfigObj
before then you need to read the section on `backwards compatibility`_.

ConfigObj now has a barrage [#]_ of doctests built into it, testing almost every
feature. Run ``python configobj.py -v`` to see them in action. Despite the tests,
ConfigObj 4 is actually smaller than version 3 and has no external dependencies.

For support and bug reports please use the ConfigObj `Mailing List`_.

.. hint::

    There is an article on using `ConfigObj for Data Persistence`_.
    
    The code from that article is available as ConfigPersist.py_.

.. _ConfigObj for Data Persistence: http://www.voidspace.org.uk/python/articles/configobj_for_data_persistence.shtml
.. _ConfigPersist.py: http://www.voidspace.org.uk/python/configpersist.html

Downloading
===========

The current version is **4.0.0**, dated 17th October 2005. ConfigObj 4 is
now stable. We may still expect to pick up a few bugs along the way though [#]_.
{sm;:-)}

You can get ConfigObj in the following ways :

Files
-----

* configobj.py_ from Voidspace

    ConfigObj has no external dependencies. This file is sufficient to access
    all the functionality except Validation_.

* configobj.zip_ from Voidspace

    This also contains validate.py_ , the `API Docs`_ and `this document`_.

* The latest development version can be obtained from the `Subversion
  Repository`_.

* validate.py_ from Voidspace

* You can also download *configobj.zip* from Sourceforge_

Documentation
-------------

*configobj.zip* contains `this document`_ and full `API Docs`_, generated by
the EpyDoc_ program.

* You can view `this document`_ online as the `ConfigObj Homepage`_.

* You can also browse the `API Docs`_ online.

Pythonutils
-----------

ConfigObj is also part of the Pythonutils_ set of modules. This contains
various other useful modules, and is required by many of the `Voidspace Python
Projects`_.

.. _configobj.py: http://www.voidspace.org.uk/cgi-bin/voidspace/downman.py?file=configobj.py
.. _configobj.zip: http://www.voidspace.org.uk/cgi-bin/voidspace/downman.py?file=configobj-4.0.0.zip
.. _validate.py: http://www.voidspace.org.uk/cgi-bin/voidspace/downman.py?file=validate.py
.. _API Docs: http://www.voidspace.org.uk/python/configobj-api/
.. _this document:
.. _configobj homepage: http://www.voidspace.org.uk/python/configobj.html
.. _Subversion Repository: http://svn.rest2web.python-hosting.com/branches/configobj4
.. _Sourceforge: http://sourceforge.net/projects/configobj
.. _EpyDoc: http://epydoc.sourceforge.net
.. _pythonutils: http://www.voidspace.org.uk/python/pythonutils.html
.. _Voidspace Python Projects: http://www.voidspace.org.uk/python

Getting Started
===============

The outstanding feature of using ConfigObj is simplicity. Most functions can be
performed with single line commands.

Reading a Config File
---------------------

The normal way to read a config file, is to give ConfigObj the filename :

.. raw:: html

    {+coloring}

    from configobj import ConfigObj
    config = ConfigObj(filename)

    {-coloring}

You can also pass the config file in as a list of lines, or a ``StringIO``
instance, so it doesn't matter where your config data comes from.

You can then access members of your config file as a dictionary. Subsections
will also be dictionaries.

.. raw:: html

    {+coloring}

    from configobj import ConfigObj
    config = ConfigObj(filename)
    #
    value1 = config['keyword1']
    value2 = config['keyword2']
    #
    section1 = config['section1']
    value3 = section1['keyword3']
    value4 = section1['keyword4']
    #
    # you could also write
    value3 = config['section1']['keyword3']
    value4 = config['section1']['keyword4']

    {-coloring}

Writing a Config File
---------------------

Creating a new config file is just as easy as reading one. You can specify a
filename when you create the ConfigObj, or do it later [#]_.

If you *don't* set a filename, then the ``write`` method will return a list of
lines instead of writing to file. See the write_ method for more details.

Here we show creating an empty ConfigObj, setting a filename and some values,
and then writing to file :

.. raw:: html

    {+coloring}

    from configobj import ConfigObj
    config = ConfigObj()
    config.filename = filename
    #
    config['keyword1'] = value1
    config['keyword2'] = value2
    #
    config['section1'] = {}
    config['section1']['keyword3'] = value3
    config['section1']['keyword4'] = value4
    #
    section2 = {
        'keyword5': value5,
        'keyword6': value6,
        'sub-section': {
            'keyword7': value7
            }
    }
    config['section2'] = section2
    #
    config['section3'] = {}
    config['section3']['keyword 8'] = [value8, value9, value10]
    config['section3']['keyword 9'] = [value11, value12, value13]
    #
    config.write()

    {-coloring}

.. caution::

    Keywords and section names can only be strings [#]_. Attempting to set
    anything else will raise a ``ValueError``.

Config Files
------------

The config files that ConfigObj will read and write are based on the 'INI'
format. This means it will read and write files created for ``ConfigParser``
[#]_.

Keywords and values are separated by an ``'='``, and section markers are
between square brackets. Keywords, values, and section names can be surrounded
by single or double quotes. Indentation is not significant, but can be
preserved.

Subsections are indicated by repeating the square brackets in the section
marker. You nest levels by using more brackets.

You can have list values by separating items with a comma, and values spanning
multiple lines by using triple quotes (single or double).

For full details on all these see `the config file format`_. Here's an example
to illustrate : ::

    # This is the 'initial_comment'
    # Which may be several lines
    keyword1 = value1
    'keyword 2' = 'value 2'

    [ "section 1" ]
    # This comment goes with keyword 3
    keyword 3 = value 3
    'keyword 4' = value4, value 5, 'value 6'

        [[ sub-section ]]    # an inline comment
        # sub-section is inside "section 1"
        'keyword 5' = 'value 7'
        'keyword 6' = '''A multiline value,
    that spans more than one line :-)
    The line breaks are included in the value.'''

            [[[ sub-sub-section ]]]
            # sub-sub-section is *in* 'sub-section'
            # which is in 'section 1'
            'keyword 7' = 'value 8'

    [section 2]    # an inline comment
    keyword8 = "value 9"
    keyword9 = value10     # an inline comment
    # The 'final_comment'
    # Which also may be several lines

ConfigObj specifications
========================

.. raw:: html

    {+coloring}

    config = ConfigObj(infile=None, options=None, **keywargs)

    {-coloring}

infile
------

You don't need to specify an infile. If you omit it, an empty ConfigObj will be
created. ``infile`` *can* be :

* Nothing. In which case the ``filename`` attribute of your ConfigObj will be
  ``None``. You can set a filename at any time.

* A filename. What happens if the file doesn't already exist is determined by
  the options_ ``file_error`` and ``create_empty``. The filename will be
  preserved as the ``filename`` attribute. This can be changed at any time.

* A list of lines. Any trailing ``\n`` will be removed from the lines. The
  ``filename`` attribute of your ConfigObj will be ``None``.

* A ``StringIO`` instance or file object, or any object with ``seek`` and
  ``read`` methods. The object you pass in will be preserved as the
  ``filename`` attribute of your ConfigObj. If it has a ``write`` method [#]_
  then you can use the ConfigObj ``write`` method. Note that a file object
  passed in won't have its ``close`` method called by ConfigObj.

* A dictionary. You can initialise a ConfigObj from a dictionary [#]_. The
  ``filename`` attribute of your ConfigObj will be ``None``. All keys must be
  strings. In this case, the order of values and sections is arbitrary.

options
-------

There are various options that control the way ConfigObj behaves. They can be
passed in as a dictionary of options, or as keyword arguments. Explicit keyword
arguments override the dictionary.

All of the options are available as attributes after the config file has been
parsed.

ConfigObj has the following options (with the default values shown) :

* 'raise_errors': ``False``

    When parsing, it is possible that the config file will be badly formed. The
    default is to parse the whole file and raise a single error at the end. You
    can set ``raise_errors = True`` to have errors raised immediately. See the
    exceptions_ section for more details.

    Altering this value after initial parsing has no effect.

* 'list_values': ``True``

    If ``True`` (the default) then list values are possible. If ``False``, the
    values are not parsed for lists.

    Altering this value after initial parsing has no effect.

* 'create_empty': ``False``

    If this value is ``True`` and the file specified by ``infile`` doesn't
    exist, ConfigObj will create an empty file. This can be a useful test that
    the filename makes sense: an impossible filename will cause an error.

    Altering this value after initial parsing has no effect.

* 'file_error': ``False``

    If this value is ``True`` and the file specified by ``infile`` doesn't
    exist, ConfigObj will raise an ``IOError``.

    Altering this value after initial parsing has no effect.

* 'interpolation': ``True``

    Whether string interpolation is switched on or not. It is on (``True``) by
    default.

    You can set this attribute to change whether string interpolation is done
    when values are fetched. See the interpolation_ section for more details.

* 'configspec': ``None``

    If you want to use the validation system, you supply a configspec. This is
    effectively a type of config file that specifies a check for each member.
    This check can be used to do type conversion as well as check that the
    value is within your required parameters.

    You provide a configspec in the same way as you do the initial file: a
    filename, or list of lines, etc. See the validation_ section for full
    details on how to use the system.

    When parsed, every section has a ``configspec`` with a dictionary of
    configspec checks for *that section*.

* 'stringify': ``True``

    If you use the validation scheme, it can do type checking *and* conversion
    for you. This means you may want to set members to integers, or other
    non-string values.

    If 'stringify' is set to ``True`` (default) then non-string values will
    be converted to strings when you write the config file. The validation_
    process converts values from strings to the required type.

    If 'stringify' is set to ``False``, attempting to set a member to a
    non-string value [#]_ will raise a ``TypeError`` (no type conversion is
    done by validation).

* 'indent_type': ``' '``

    Indentation is not significant; it can however be present in the output
    config. Allowable values are: ``''`` (no indentation), ``' '`` (indentation
    with spaces, fixed at four per level), or ``'\t'`` (indentation with tabs,
    one tab per level).

    If this option is not specified, and the ConfigObj is initialised with a
    dictionary, the indentation used in the output is the default one, that is,
    spaces.

    If this option is not specified, and the ConfigObj is initialised with a
    list of lines or a file, the indentation used in the first indented line is
    selected and used in all output lines. If no input line is indented, no
    output line will be either.

    If this option *is* specified, the option value is used in the output
    config, overriding the type of indentation in the input config (if any).

Methods
-------

The ConfigObj is a subclass of an object called ``Section``, which is itself a
subclass of ``dict``, the builtin dictionary type. This means it also has
**all** the normal dictionary methods.

In addition, the *encode*, *decode*, *walk*, and *dict* methods of section may
be useful. The sections and subsections are also instances of ``Section``. Read
about Sections_ for details of all the methods.

The public methods available on ConfigObj are :

* 'write'
* 'validate'

write
~~~~~

This method takes no arguments [#]_. It writes the current ConfigObj. What that
means depends on the ``filename`` attribute of the ConfigObj.

filename
    ConfigObj will write the configuration to file.

``None``
    ``write`` returns a list of lines. (Not ``'\n'`` terminated)

``StringIO``
    If ``filename`` is an object with a seek attribute, then the config file is
    written to that object.

First the 'initial_comment' is written, then the config file, followed by the
'final_comment'. Comment lines and inline comments are written with each
key/value.

validate
~~~~~~~~

.. raw:: html

    {+coloring}

    # filename is the config file
    # filename2 is the configspec
    # (which could also be hardcoded into your program)
    config = ConfigObj(filename, configspec=filename2)
    #
    from validate import Validator
    val = Validator()
    test = config.validate(val)
    if test == True:
        print 'Succeeded.'

    {-coloring}

This method validates the ConfigObj against the configspec. By doing type
conversion as well, it can abstract away the config file altogether and present
the config *data* to your application (in the types it expects it to be).

If the ``configspec`` attribute of the ConfigObj is ``None``, it raises a
``ValueError``.

If the stringify_ attribute is set, this process will convert values to the
type defined in the configspec.

The validate method uses checks specified in the configspec and defined in the
``Validator`` object. It is very easy to extend.

The configspec looks like the config file, but instead of the value, you
specify the check (and any default value). See the validation_ section for
details.

.. hint::

    If your ConfigObj is only comprised of basic data types, then you can use
    a function from the ConfigPersist.py_ module to auto-generate your
    configspec.
    
    See `ConfigObj for Data Persistence`_.

Return Value
############

The validate method either returns ``True`` (everything passed) or a dictionary 
of ``True``/``False`` representing pass/fail. The dictionary follows the 
structure of the ConfigObj

If a whole section passes then it is replaced with the value ``True``. If a 
whole section fails, then it is replaced with the value ``False``.

If a value is missing, and there is no default in the check, then the check 
automatically fails.

Mentioning Default Values
#########################

In the check in your configspec, you can specify a default to be used - by 
using the ``default`` keyword. E.g. ::

    key1 = integer(0, 30, default=15)
    key2 = integer(default=15)
    key3 = boolean(default=True)
    key4 = option('Hello', 'Goodbye', 'Not Today', default='Not Today')

If the configspec check supplies a default and the value is missing in the
config, then the default will be set in your ConfigObj. (It is still passed to
the ``Validator`` so that type conversion can be done: this means the default
value must still pass the check.)

ConfigObj keeps a record of which values come from defaults, using the
``defaults`` attribute of sections_. Any key in this list isn't written out by
the ``write`` method. If a key is set from outside (even to the same value)
then it is removed from the ``defaults`` list.

.. note:

    Even if all the keys in a section are in the defaults list, the section
    marker is still written out.

There is additionally a special case default value of ``None``. If you set the
default value to ``None`` and the value is missing, the value will always be
set to ``None``. As the other checks don't return ``None`` (unless you
implement your own that do), you can tell that this value came from a default
value (and was missing from the config file). It allows an easy way of
implementing optional values. Simply check (and ignore) members that are set
to ``None``.

.. note::

    If stringify_ is ``False`` then ``default=None`` returns ``''`` instead of
    ``None``. This is because setting a value to a non-string raises an error
    if stringify is unset.

Mentioning Repeated Sections
############################

In the configspec it is possible to cause *every* sub-section in a section to
be validated using the same configspec. You do this with a section in the
configspec  called ``__many__``. Every sub-section in that section has the
``__many__`` configspec applied to it (without you having to explicitly name
them in advance).

If you define a ``__many__`` type section it must the only sub-section in that
section. Having a ``__many__`` *and* other sub-sections defined in the same
section will raise a ``RepeatSectionError``.

Your ``__many__`` section can have nested subsections, which can also include
``__many__`` type sections.

See `Repeated Sections`_ for examples.

Mentioning SimpleVal
####################

If you just want to check if all members are present, then you can use the
``SimpleVal`` object that comes with ConfigObj. It only fails members if they
are missing.

Write a configspec that has all the members you want to check for, but set
every section to ``''``.

.. raw:: html

    {+coloring}

    val = SimpleVal()
    test = config.validate(val)
    if test is True:
        print 'Succeeded.'

    {-coloring}

Attributes
----------

A ConfigObj has the following attributes :

* indent_type
* interpolate
* stringify
* BOM
* initial_comment
* final_comment

.. note::

    This doesn't include *comments*, *inline_comments*, *defaults*, or
    *configspec*. These are actually attributes of Sections_.

It also has the following attributes as a result of parsing. They correspond to
options_ when the ConfigObj was created, but changing them has no effect.

* raise_errors
* create_empty
* file_error
* list_values

interpolate
~~~~~~~~~~~

ConfigObj can perform string interpolation in a *similar* way to
``ConfigParser``. See the interpolation_ section for full details.

If ``interpolate`` is set to ``False``, then interpolation is *not* done when
you fetch values.

stringify
~~~~~~~~~

If this attribute is set (``True``) then the validate_ method changes the
values in the ConfigObj. These are turned back into strings when write_ is
called.

If stringify is unset (``False``) then attempting to set a value to a non
string (or a list of strings) will raise a ``TypeError``.

BOM
~~~

If the initial config file *started* with the UTF8 Unicode signature (known
slightly incorrectly as the {acro;BOM;Byte Order Mark}), then this value will
be set to the UTF8 BOM. Otherwise it is ``None``.

If it is set, then it is  written out by the ``write`` method.

initial_comment
~~~~~~~~~~~~~~~

This is a list of lines. If the ConfigObj is created from an existing file, it
will contain any lines of comments before the start of the members.

If you create a new ConfigObj, this will be an empty list.

The write method puts these lines before it starts writing out the members.

final_comment
~~~~~~~~~~~~~

This is a list of lines. If the ConfigObj is created from an existing file, it
will contain any lines of comments after the last member.

If you create a new ConfigObj, this will be an empty list.

The ``write`` method puts these lines after it finishes writing out the
members.

The Config File Format
======================

You saw an example config file in the `Config Files`_ section. Here is a fuller
specification of the config files used and created by ConfigObj.

The basic pattern for keywords is : ::

    # comment line
    # comment line
    keyword = value # inline comment

Both keyword and value can optionally be surrounded in quotes. The equals sign
is the only valid divider.

Values can have comments on the lines above them, and an inline comment after
them. This, of course, is optional. See the comments_ section for details.

If a keyword or value starts or ends with whitespace, or contains a quote mark
or comma, then it should be surrounded by quotes. Quotes are not necessary if
whitespace is surrounded by non-whitespace.

Values can also be lists. Lists are comma separated. You indicate a single
member list by a trailing comma. An empty list is shown by a single comma : ::

    keyword1 = value1, value2, value3
    keyword2 = value1, # a single member list
    keyword3 = , # an empty list

Values that contain line breaks (multi-line values) can be surrounded by triple
quotes. These can also be used if a value contains both types of quotes. List
members cannot be surrounded by triple quotes : ::

    keyword1 = ''' A multi line value
    on several
    lines'''     # with a comment
    keyword2 = '''I won't be "afraid".'''
    #
    keyword3 = """ A multi line value
    on several
    lines"""     # with a comment
    keyword4 = """I won't be "afraid"."""

.. warning::

    There is no way of safely quoting values that contain both types of triple
    quotes.

A line that starts with a '#', possibly preceded by whitespace, is a comment.

New sections are indicated by a section marker line. That is the section name
in square brackets. Whitespace around the section name is ignored. The name can
be quoted with single or double quotes. The marker can have comments before it
and an inline comment after it : ::

    # The First Section
    [ section name 1 ] # first section
    keyword1 = value1

    # The Second Section
    [ "section name 2" ] # second section
    keyword2 = value2

Any subsections (sections that are *inside* the current section) are
designated by repeating the square brackets before and after the section name.
The number of square brackets represents the nesting level of the sub-section.
Square brackets may be separated by whitespace; such whitespace, however, will
not be present in the output config written by the ``write`` method.

Indentation is not significant, but can be preserved. See the description of
the ``indent_type`` option, in the `ConfigObj specifications`_ chapter, for the
details.

A *NestingError* will be raised if the number of the opening and the closing
brackets in a section marker is not the same, or if a sub-section's nesting
level is greater than the nesting level of it parent plus one.

In the outer section, single values can only appear before any sub-section.
Otherwise they will belong to the sub-section immediately before them. ::

    # initial comment
    keyword1 = value1
    keyword2 = value2

    [section 1]
    keyword1 = value1
    keyword2 = value2

        [[sub-section]]
        # this is in section 1
        keyword1 = value1
        keyword2 = value2

            [[[nested section]]]
            # this is in sub section
            keyword1 = value1
            keyword2 = value2

        [[sub-section2]]
        # this is in section 1 again
        keyword1 = value1
        keyword2 = value2

    [[sub-section3]]
    # this is also in section 1, indentation is misleading here
    keyword1 = value1
    keyword2 = value2

    # final comment

When parsed, the above config file produces the following data structure :

.. raw:: html

    {+coloring}

    {
        'keyword1': 'value1',
        'keyword2': 'value2',
        'section 1': {
            'keyword1': 'value1',
            'keyword2': 'value2',
            'sub-section': {
                'keyword1': 'value1',
                'keyword2': 'value2',
                'nested section': {
                    'keyword1': 'value1',
                    'keyword2': 'value2',
                },
            },
            'sub-section2': {
                'keyword1': 'value1',
                'keyword2': 'value2',
            },
            'sub-section3': {
                'keyword1': 'value1',
                'keyword2': 'value2',
            },
        },
    }

    {-coloring}

Sections are ordered: note how the structure of the resulting ConfigObj is in
the same order as the original file.

Sections
========

Every section in a ConfigObj has certain properties. The ConfigObj itself also
has these properties, because it too is a section (sometimes called the *root
section*).

``Section`` is a subclass of the standard new-class dictionary, therefore it
has **all** the methods of a normal dictionary. This means you can ``update``
and ``clear`` sections.

.. note::

    You create a new section by assigning a member to be a dictionary.
    
    The new ``Section`` is created *from* the dictionary, but isn't the same
    thing as the dictionary. (So references to the dictionary you use to create
    the section *aren't* references to the new section).
    
    Note the following.

    .. raw:: html
    
        {+coloring}
        
        config = ConfigObj()
        vals = {'key1': 'value 1', 
                'key2': 'value 2'
               }
        config['vals'] = vals
        config['vals'] == vals
        True
        config['vals'] is vals
        False
        
        {-coloring}
     
    If you now change ``vals``, the changes won't be reflected in ``config['vals']``.

A section is ordered, following its ``scalars`` and ``sections``
attributes documented below. This means that the following dictionary
attributes return their results in order.

* '__iter__'

    More commonly known as ``for member in section:``.

* '__repr__' and '__str__'

    Any time you print or display the ConfigObj.

* 'items'

* 'iteritems'

* 'iterkeys'

* 'itervalues'

* 'keys'

* 'popitem'

* 'values'

Section Attributes
------------------

* main

    A reference to the main ConfigObj.

* parent

    A reference to the 'parent' section, the section that this section is a
    member of.

    On the ConfigObj this attribute is a reference to itself. You can use this
    to walk up the sections, stopping when ``section.parent is section``.

* depth

    The nesting level of the current section.

    If you create a new ConfigObj and add sections, 1 will be added to the
    depth level between sections.

* defaults

    This attribute is a list of scalars that came from default values. Values
    that came from defaults aren't written out by the ``write`` method.
    Setting any of these values in the section removes them from the defaults
    list.

* scalars, sections

    These attributes are normal lists, representing the order that members,
    single values and subsections appear in the section. The order will either
    be the order of the original config file, *or* the order that you added
    members.

    The order of members in this lists is the order that ``write`` creates in
    the config file. The ``scalars`` list is output before the ``sections``
    list.

    Adding or removing members also alters these lists. You can manipulate the
    lists directly to alter the order of members.

    .. warning::

        If you alter the ``scalars``, ``sections``, or ``defaults`` attributes
        so that they no longer reflect the contents of the section, you will
        break your ConfigObj.

    See also the ``rename`` method.

* comments

    This is a dictionary of comments associated with each member. Each entry is
    a list of lines. These lines are written out before the member.

* inline_comments

    This is *another* dictionary of comments associated with each member. Each
    entry is a string that is put inline with the member.

* configspec

    The configspec attribute is a dictionary mapping scalars to *checks*. A
    check defines the expected type and possibly the allowed values for a
    member.

    The configspec has the same format as a config file, but instead of values
    it has a specification for the value (which may include a default value).
    The validate_ method uses it to check the config file makes sense. If a
    configspec is passed in when the ConfigObj is created, then it is parsed
    and broken up to become the ``configspec`` attribute of each section.

    If you didn't pass in a configspec, this attribute will be ``None`` on the
    root section (the main ConfigObj).

    You can set the configspec attribute directly on a section.

    See the validation_ section for full details of how to write configspecs.

Section Methods
---------------

* 'dict'

    This method takes no arguments. It returns a deep copy of the section as a
    dictionary. All subsections will also be dictionaries, and list values will
    be copies, rather than references to the original [#]_.

* rename

    ``rename(oldkey, newkey)``

    This method renames a key, without affecting its position in the sequence.

    It is mainly implemented for the ``encode`` and ``decode`` methods, which
    provide some Unicode support.

* walk

    This method can be used to transform values and names. See `walking a
    section`_ for examples and explanation.

* decode

    ``decode(encoding)``

    This method decodes names and values into Unicode objects, using the
    supplied encoding.

    Because of the way ConfigObj reads files, config files should be in an
    ASCII compatible encoding. See encodings_ for more details.

* encode

    ``encode(encoding)``

    This method is the opposite of ``decode`` {sm;:!:}.

    It encodes names and values using the supplied encoding. If any of your
    names/values are strings rather than Unicode, Python will have to do an
    implicit decode first.

    See encodings_ for more details.

Walking a Section
-----------------

.. note::

    The walk method allows you to call a function on every member/name.

.. raw:: html

    {+coloring}

        walk(function, raise_errors=True,
            call_on_sections=False, **keywargs):

    {-coloring}

``walk`` is a method of the ``Section`` object. This means it is also a method
of ConfigObj.

It walks through every member and calls a function on the keyword and value. It
walks recursively through subsections.

It returns a dictionary of all the computed values.

If the function raises an exception, the default is to propagate the error, and
stop. If ``raise_errors=False`` then it sets the return value for that keyword
to ``False`` instead, and continues. This is similar to the way validation_
works.

Your function receives the arguments ``(section, key)``. The current value is
then ``section[key]`` [#]_. Any unrecognised keyword arguments you pass to
walk, are passed on to the function.

Normally ``walk`` just recurses into subsections. If you are transforming (or
checking) names as well as values, then you want to be able to change the names
of sections. In this case set ``call_on_sections`` to ``True``. Now, on
encountering a sub-section, *first* the function is called for the *whole*
sub-section, and *then* it recurses into it's members. This means your function
must be able to handle receiving dictionaries as well as strings and lists.

If you are using the return value from ``walk`` *and* ``call_on_sections``,
note that walk discards the return value when it calls your function.

Examples
--------

Examples that use the walk method are the ``encode`` and ``decode`` methods.
They both define a function and pass it to walk. Because these functions
transform names as well as values (from byte strings to Unicode) they set
``call_on_sections=True``.

To see how they do it, *read the source Luke* {sm;:cool:}.

You can use this for transforming all values in your ConfigObj. For example
you might like the nested lists from ConfigObj 3. This was provided by the
listquote_ module [#]_. You could switch off the parsing for list values
(``list_values=False``) and use listquote to parse every value.

Another thing you might want to do is use the Python escape codes in your
values. You might be *used* to using ``\n`` for line feed and ``\t`` for tab.
Obviously we'd need to decode strings that come from the config file (using the
escape codes). Before writing out we'll need to put the escape codes back in
encode.

As an example we'll write a function to use with walk, that encodes or decodes
values using the ``string-escape`` codec.

The function has to take each value and set the new value. As a bonus we'll
create one function that will do decode *or* encode depending on a keyword
argument.

We don't want to work with section names, we're only transforming values, so
we can leave ``call_on_sections`` as ``False``. This means the two datatypes we
have to handle are strings and lists, we can ignore everything else. (We'll
treat tuples as lists as well).

We're not using the return values, so it doesn't need to return anything, just
change the values if appropriate.

.. raw:: html

    {+coloring}

    def string_escape(section, key, encode=False):
        """
        A function to encode or decode using the 'string-escape' codec.
        To be passed to the walk method of a ConfigObj.
        By default it decodes.
        To encode, pass in the keyword argument ``encode=True``.
        """
        val = section[key]
        # is it a type we can work with
        # NOTE: for platforms where Python > 2.2
        # you can use basestring instead of (str, unicode)
        if not isinstance(val, (str, unicode, list, tuple)):
            # no !
            return
        elif isinstance(val, (str, unicode)):
            # it's a string !
            if not encode:
                section[key] = val.decode('string-escape')
            else:
                section[key] = val.encode('string-escape')
        else:
            # it must be a list or tuple!
            # we'll be lazy and create a new list
            newval = []
            # we'll check every member of the list
            for entry in val:
                if isinstance(entry, (str, unicode)):
                    if not encode:
                        newval.append(entry.decode('string-escape'))
                    else:
                       newval.append(entry.encode('string-escape'))
                else:
                    newval.append(entry)
            # done !
            section[key] =  newval

    # assume we have a ConfigObj called ``config``
    #
    # To decode
    config.walk(string_escape)
    #
    # To encode.
    # Because ``walk`` doesn't recognise the ``encode`` argument
    # it passes it to our function.
    config.walk(string_escape, encode=True)

    {-coloring}

Exceptions
==========

There are several places where ConfigObj may raise exceptions (other than
because of bugs).

1) If a configspec filename you pass in doesn't exist, or a config file
    filename doesn't exist *and* ``file_error=True``, an ``IOError`` will be
    raised.

2) If you try to set a non-string key, or a non string value when
    ``stringify=False`, a ``TypeError`` will be raised.

3) A badly built config file will cause parsing errors.

4) A parsing error can also occur when reading a configspec.

5) In string interpolation you can specify a value that doesn't exist, or
    create circular references (recursion).

6) If you have a ``__many__`` repeated section with other section definitions
    (in a configspec), a ``RepeatSectionError`` will be raised.

Number 5 (which is actually two different types of exceptions) is documented
    in interpolation_.

Number 6 is explained in the validation_ section.

*This* section is about errors raised during parsing.

The base error class is ``ConfigObjError``. This is a subclass of
``SyntaxError``, so you can trap for ``SyntaxError`` without needing to
directly import any of the ConfigObj exceptions.

The following other exceptions are defined (all deriving from
``ConfigObjError``) :

* ``NestingError``

    This error indicates either a mismatch in the brackets in a section marker,
    or an excessive level of nesting.

* ``ParseError``

    This error indicates that a line is badly written. It is neither a valid
    ``key = value`` line, nor a valid section marker line, nor a comment line.

* ``DuplicateError``

    The keyword or section specified already exists.

* ``ConfigspecError``

    An error occured whilst parsing a configspec.

When parsing a configspec, ConfigObj will stop on the first error it
encounters.  It will raise a ``ConfigspecError``. This will have an ``error``
attribute, which is the actual error that was raised.

Behavior when parsing a config file depends on the option ``raise_errors``.
If ConfigObj encounters an error while parsing a config file:

    If ``raise_errors=True`` then ConfigObj will raise the appropriate error
    and parsing will stop.

    If ``raise_errors=False`` (the default) then parsing will continue to the
    end and *all* errors will be collected.

In the second case a ``ConfigObjError`` is raised after parsing has stopped.
The error raised has a ``config`` attribute, which is the parts of the
ConfigObj that parsed successfully. It also has an attribute ``errors``, which
is a list of *all* the errors raised. Each entry in the list is an instance of
the appropriate error type. Each one has the following attributes (useful for
delivering a sensible error message to your user) :

* ``line``: the original line that caused the error.

* ``line_number``: its number in the config file.

* ``message``: the error message that accompanied the error.

.. note::

    One wrongly written line could break the basic structure of your config
    file. This could cause every line after it to flag an error, so having a
    list of all the lines that caused errors may not be as useful as it sounds.
    {sm;:-(}.

Validation
==========

Validation is done through a combination of the configspec_ and a ``Validator``
object. For this you need *validate.py* [#]_. See downloading_ if you don't
have a copy.

Validation can perform two different operations :

1) Check that a value meets a specification. For example, check that a value
    is an integer between one and six, or is a choice from a specific set of
    options.

2) It can convert the value into the type required. For example, if one of
    your values is a port number, validation will turn it into an integer for
    you.

So validation can act as a transparent layer between the datatypes of your
application configuration (boolean, integers, floats, etc) and the text format
of your config file.

configspec
----------

The ``validate`` method checks members against an entry in the configspec. Your
configspec therefore resembles your config file, with a check for every member.

In order to perform validation you need a ``Validator`` object. This has
several useful built-in check functions. You can also create your own custom
functions and register them with your Validator object.

Each check is the name of one of these functions, including any parameters and
keyword arguments. The configspecs look like function calls, and they map to
function calls.

The basic datatypes that an un-extended Validator can test for are :

* boolean values (True and False)
* integers (including minimum and maximum values)
* floats (including min and max)
* strings (including min and max length)
* IP addresses (v4 only)

It can also handle lists of these types and restrict a value to being one from
a set of options.

An example configspec is going to look something like : ::

    port = integer(0, 100)
    user = string(max=25)
    mode = option('quiet', 'loud', 'silent')

You can specify default values, and also have the same configspec applied to
several sections. This is called `repeated sections`_.

For full details on writing configspecs, please refer to the `validate.py
documentation`_.

.. _validate.py documentation: http://www.voidspace.org.uk/python/validate.html

Type Conversion
---------------

By default, validation does type conversion. This means that if you specify
``integer`` as the check, then calling validate_ will actually change the value
to an integer (so long as the check succeeds).

It also means that when you call the write_ method, the value will be converted
back into a string using the ``str`` function.

To switch this off, and leave values as strings after validation, you need to
set the stringify_ attribute to ``False``. If this is the case, attempting to
set a value to a non-string will raise an error.

Default Values
--------------

You can set a default value in your check. If the value is missing from the
config file then this value will be used instead. This means that your user
only has to supply values that differ from the defaults.

If you *don't* supply a default then for a value to be missing is an error,
and this will show in the `return value`_ from validate.

Additionally you can set the default to be ``None``. This means the value will
be set to ``None`` (the object) *whichever check is used*. (It will be set to
``''`` rather than ``None`` if stringify_ is ``False``). You can use this
to easily implement optional values in your config files. ::

    port = integer(0, 100, default=80)
    user = string(max=25, default=0)
    mode = option('quiet', 'loud', 'silent', default='loud')
    nick = string(default=None)

.. note::

    Because the default goes through type conversion, it also has to pass the
    check.

    Note that ``default=None`` is case sensitive.

Repeated Sections
-----------------

Repeated sections are a way of specifying a configspec for a section that
should be applied to *all* subsections in the same section.

The easiest way of explaining this is to give an example. Suppose you have a
config file that describes a dog. That dog has various attributes, but it can
also have many fleas. You don't know in advance how many fleas there will be,
or what they will be called, but you want each flea validated against the same
configspec.

We can define a section called *fleas*. We want every flea in that section
(every sub-section) to have the same configspec applied to it. We do this by
defining a single section called ``__many__``. ::

    [dog]
    name = string(default=Rover)
    age = float(0, 99, default=0)

        [[fleas]]

            [[[__many__]]]
            bloodsucker = boolean(default=True)
            children = integer(default=10000)
            size = option(small, tiny, micro, default=tiny)

Every flea on our dog will now be validated using the ``__many__`` configspec.

If you define another sub-section in a section *as well as* a ``__many__`` then
you will get an error.

``__many__`` sections can have sub-sections, including their own ``__many__``
sub-sections. Defaults work in the normal way in repeated sections.


Validation and Interpolation
----------------------------

String interpolation and validation don't play well together. When validation
changes type it sets the value. If the value uses interpolation, then the 
interpolation reference would normally be overwritten. Calling ``write`` would
then use the absolute value and the interpolation reference would be lost.

As a compromise - if the value is unchanged by validation then it is not reset.
This means strings that pass through validation unmodified will not be 
overwritten. If validation changes type - the value has to be overwritten, and
any interpolation references are lost {sm;:-(}.

SimpleVal
---------

You may not need a full validation process, but still want to check if all the
expected values are present.

Provided as part of the ConfigObj module is the ``SimpleVal`` object. This has
a dummy ``test`` method that always passes.

The only reason a test will fail is if the value is missing. The return value
from ``validate`` will either be ``True``, meaning all present, or a dictionary
with ``False`` for all missing values/sections.

To use it, you still need to pass in a valid configspec when you create the
ConfigObj, but just set all the values to ``''``. Then create an instance of
``SimpleVal`` and pass it to the ``validate`` method.

As a trivial example if you had the following config file : ::

    # config file for an application
    port = 80
    protocol = http
    domain = voidspace
    top_level_domain = org.uk

You would write the following configspec : ::

    port = ''
    protocol = ''
    domain = ''
    top_level_domain = ''

.. raw:: html

    {+coloring}

    config = Configobj(filename, configspec=configspec)
    val = SimpleVal()
    test = config.validate(val)
    if test == True:
        print 'All values present.'
    elif test == False:
        print 'No values present!'
    else:
        for entry in test:
            if test[entry] == False:
                print '"%s" missing.' % entry

    {-coloring}

Interpolation
=============

ConfigObj allows string interpolation *similar* to the way ``ConfigParser``

You specify a value to be substituted by including ``%(name)s`` in the value.

Interpolation checks first the 'DEFAULT' sub-section of the current section to
see if ``name`` is the key to a value. ('name' is case sensitive).

If it doesn't find it, next it checks the 'DEFAULT' section of the parent
section, last it checks the 'DEFAULT' section of the main section.

If the value specified isn't found then a ``MissingInterpolationOption`` error
is raised (a subclass of ``ConfigObjError``).

If it is found then the returned value is also checked for substitutions. This
allows you to make up compound values (for example directory paths) that use
more than one default value. It also means it's possible to create circular
references. If after ten replacements there are still values to substitute, an
``InterpolationDepthError`` is raised.

Both of these errors are subclasses of ``InterpolationError``, which is a
subclass of ``ConfigObjError``.

String interpolation and validation don't play well together. This is because 
validation overwrites values - and so may erase the interpolation references.
See `Validation and Interpolation`_. (This can only happen if validation
has to *change* the value).

Comments
========

Any line that starts with a '#', possibly preceded by whitespace, is a comment.

If a config file starts with comments then these are preserved as the
initial_comment_.

If a config file ends with comments then these are preserved as the
final_comment_.

Every key or section marker may have lines of comments immediately above it.
These are saved as the ``comments`` attribute of the section. Each member is a
list of lines.

You can also have a comment inline with a value. These are saved as the
``inline_comments`` attribute of the section, with one entry per member of the
section.

Subsections (section markers in the config file) can also have comments.

See `Section Attributes`_ for more on these attributes.

These comments are all written back out by the ``write`` method.

Encodings
=========

ConfigObj 4 is designed to work with ASCII compatible encodings [#]_. If you
need support for other character sets, then I suggest you use the UTF8
encoding for your config files.

By default ConfigObj leaves keys/members as encoded byte strings (ordinary
strings). If you want to access the config file members as Unicode objects
rather than strings, you can use the ``decode`` method. This takes an encoding
as its argument and decodes all members and keys into Unicode. It will only
work if *all* members are byte strings (or lists of strings) , so you should do
it before calling ``validate``.

If you want to turn the Unicode strings back into byte strings, you can call
the ``encode`` method. This also takes an encoding as its argument and assumes
*all* keys/members are Unicode.

If you start working with Unicode strings, you may find you get
``UnicodeDecodeError`` or ``UnicodeEncodeError`` in unexpected places. This is
because you have forced Python to do an *implicit* encode or decode.

Implicit decodes (and encodes) use the encoding returned by
``sys.getdefaultencoding()``. This is *usually* ASCII. This means that if you
have any non-ASCII characters, Python doesn't know how to treat them and will
raise an error.

This happens if you add a byte string to a Unicode string, compare a byte
string to a Unicode string, print a Unicode string, or write it to a file. If
you work with Unicode, you should do the appropriate encode or decode first.

Backwards Compatibility
=======================

There have been a lot of changes since ConfigObj 3. The core parser is now
based on regular expressions, and is a lot faster and smaller. There is now no
difference in the way we treat flat files and non-flatfiles, that is, no empty
sections. This means some of the code can be a lot simpler, less code does
more of the work [#]_.

There have been other simplifications: for example we only have eight options
instead of seventeen.

Most config files created for ConfigObj 3 will be read with no changes and many
programs will work without having to alter code. Some of the changes do break
backwards compatibility: for example, code that uses the previous options will
now raise an error. It should be very easy to fix these, though.

Below is a list of all the changes that affect backwards compatibility. This
doesn't include details of method signatures that have changed, because almost
all of them have.

Incompatible Changes
--------------------

(I have removed a lot of needless complications: this list is probably not
conclusive, many option/attribute/method names have changed.)

Case sensitive.

The only valid divider is '='.

Line continuations with ``\`` removed.

No recursive lists in values.

No empty sections.

No distinction between flatfiles and non flatfiles.

Change in list syntax: use commas to indicate list, not parentheses (square
brackets and parentheses are no longer recognised as lists).

';' is no longer valid for comments, and no multiline comments.

No attribute-style access to values.

Empty values not allowed: use '' or "".

In ConfigObj 3, setting a non-flatfile member to ``None`` would initialise it
as an empty section.

The escape entities '&mjf-lf;' and '&mjf-quot;' have gone, replaced by triple
quote, multiple line values.

The ``newline``, ``force_return``, and ``default`` options have gone.

The ``encoding`` and ``backup_encoding`` methods have gone, replaced with the
``encode`` and ``decode`` methods.

``fileerror`` and ``createempty`` options have become ``file_error`` and
``create_empty``.

Partial configspecs (for specifying the order members should be written out,
and which should be present) have gone. The configspec is no longer used to
specify order for the ``write`` method.

Exceeding the maximum depth of recursion in string interpolation now raises an
error ``InterpolationDepthError``.

Specifying a value for interpolation which doesn't exist now raises a
``MissingInterpolationOption`` error (instead of merely being ignored).

The ``writein`` method has been removed.

The comments attribute is now a list (``inline_comments`` equates to the old
comments attribute).

ConfigObj 3
-----------

ConfigObj 3 is now deprecated in favour of ConfigObj 4. I can fix bugs in
ConfigObj 3 if needed, though.

For anyone who still needs it, you can download it here: `ConfigObj 3.3.1`_

You can read the old docs at : `ConfigObj 3 Docs`_

.. _ConfigObj 3.3.1: http://www.voidspace.org.uk/cgi-bin/voidspace/downman.py?file=configobj3.zip
.. _ConfigObj 3 Docs: http://www.voidspace.org.uk/python/configobj3.html

CREDITS
=======

ConfigObj 4 is written by (and copyright) `Michael Foord`_ and 
`Nicola Larosa`_.

Particularly thanks to Nicola Larosa for help on the config file spec, the
validation system and the doctests.

*validate.py* was originally written by Michael Foord and `Mark Andrews`_.

Thanks to others for input and bugfixes.

LICENSE
=======

ConfigObj, and related files, are licensed under the BSD license. This is a
very unrestrictive license, but it comes with the usual disclaimer. This is
free software: test it, break it, just don't blame us if it eats your data !
Of course if it does, let us know and we'll fix the problem so it doesn't
happen to anyone else {sm;:-)}. ::

    Copyright (c) 2004 & 2005, Michael Foord & Nicola Larosa
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:


        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials provided
          with the distribution.

        * Neither the name of Michael Foord nor Nicola Larosa
          may be used to endorse or promote products derived from this
          software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

You should also be able to find a copy of this license at : `BSD License`_

.. _BSD License: http://www.voidspace.org.uk/documents/BSD-LICENSE.txt

TODO
====

Fix any bugs (and resolvable issues).

Do an example for the 'walk' which removes uniform indentation in multiline
values.

When initialising a section from a ConfigObj *or* an ``OrderedDictionary``
we could preserve ordering.

Add an *odict* method which returns an `OrderedDictionary``.

ISSUES
======

.. note::

    Please file any bug reports to `Michael Foord`_ or the ConfigObj
    `Mailing List`_.

You can't have a keyword with the same name as a section (in the same section).
They are both dictionary keys, so they would overlap.

Interpolation checks first the 'DEFAULT' sub-section of the current section,
next it checks the 'DEFAULT' section of the parent section, last it checks the
'DEFAULT' section of the main section.

Logically a 'DEFAULT' section should apply to all subsections of the *same
parent*: this means that checking the 'DEFAULT' sub-section in the *current
section* is not necessarily logical ?

In order to simplify Unicode support (which is possibly of limited value
in a config file ?) I have removed automatic support, and added thev``encode``
and ``decode`` methods. These can be used to transform keys and entries.
Because the regex looks for specific values on inital parsing (i.e. the quotes
and the equals signs) it can only read ASCII compatible encodings. For Unicode
I suggest ``UTF8``, which is ASCII compatible.

.. note::

    There is no reason why you shouldn't decode your config file into Unicode
    before passing them to ConfigObj (as a list of lines). This should give you
    Unicode keys and values.

Does it matter that we don't support the ':' divider, which is supported by
``ConfigParser`` ?

Following error with "list_values=False" : ::

    >>> a = ["a='hello', 'goodbye'"]
    >>>
    >>> c(a, list_values=False)
    {'a': "hello', 'goodbye"}

The regular expression correctly removes the value - ``"'hello', 'goodbye'"`` -
and then unquote just removes the front and back quotes (called by
``_handle_value``). What should we do ?? We *ought* to raise an exception - 
because if lists are off it's an invalid value. This is not desired if you want 
to do your own list processing e.g. using listquote for nested lists. It would
be *better* in this case not to unquote. Raising an exception would require a
new regex.

String interpolation and validation don't play well together. See 
`Validation and Interpolation`_.

CHANGELOG
=========

This is an abbreviated changelog showing the major releases up to version 4.
From version 4 it lists all releases and changes. *More* data on individual
changes may be found in the source code.

2005/10/17 - Version 4.0.0
--------------------------

**ConfigObj 4.0.0 Final**

Fixed bug in ``setdefault``. When creating a new section with setdefault the
reference returned would be to the dictionary passed in *not* to the new 
section. Bug fixed and behaviour documented.

Obscure typo/bug fixed in ``write``. Wouldn't have affected anyone though.

2005/09/09 - Version 4.0.0 beta 5
---------------------------------

Removed ``PositionError``.

Allowed quotes around keys as documented.

Fixed bug with commas in comments. (matched as a list value)

2005/09/07 - Version 4.0.0 beta 4
---------------------------------

Fixed bug in ``__delitem__``. Deleting an item no longer deletes the 
``inline_comments`` attribute.

Fixed bug in initialising ConfigObj from a ConfigObj.

Changed the mailing list address.

2005/08/28 - Version 4.0.0 beta 3
---------------------------------

Interpolation is switched off before writing out files.

Fixed bug in handling ``StringIO`` instances. (Thanks to report from
"Gustavo Niemeyer" <gustavo@niemeyer.net>)

Moved the doctests from the ``__init__`` method to a separate function.
(For the sake of IDE calltips).

2005/08/25 - Version 4.0.0 beta 2
---------------------------------

Amendments to *validate.py*.

Official release.

2005/08/21 - Version 4.0.0 beta 1
---------------------------------

Reads nested subsections to any depth.

Multiline values.

Simplified options and methods.

New list syntax.

Faster, smaller, and better parser.

Validation greatly improved. Includes:

    * type conversion
    * default values
    * repeated sections

Improved error handling.

Plus lots of other improvements {sm;:grin:}.

2004/05/24 - Version 3.0.0
--------------------------

Several incompatible changes: another major overhaul and change. (Lots of
improvements though).

Added support for standard config files with sections. This has an entirely
new interface: each section is a dictionary of values.

Changed the update method to be called writein: update clashes with a dict
method.

Made various attributes keyword arguments, added several.

Configspecs and orderlists have changed a great deal.

Removed support for adding dictionaries: use update instead.

Now subclasses a new class called caselessDict. This should add various
dictionary methods that could have caused errors before.

It also preserves the original casing of keywords when writing them back out.

Comments are also saved using a ``caselessDict``.

Using a non-string key will now raise a ``TypeError`` rather than converting 
the key.

Added an exceptions keyword for *much* better handling of errors.

Made ``creatempty=False`` the default.

Now checks indict *and* any keyword args. Keyword args take precedence over
indict.

``' ', ':', '=', ','`` and ``'\t'`` are now all valid dividers where the 
keyword is unquoted.

ConfigObj now does no type checking against configspec when you set items.

delete and add methods removed (they were unnecessary).

Docs rewritten to include all this gumph and more; actually ConfigObj is
*really* easy to use.

Support for stdout was removed.

A few new methods added.

Charmap is now incorporated into ConfigObj.

2004/03/14 - Version 2.0.0 beta
-------------------------------

Re-written it to subclass dict. My first forays into inheritance and operator
overloading.

The config object now behaves like a dictionary.

I've completely broken the interface, but I don't think anyone was really
 using it anyway.

This new version is much more 'classy' {sm;:wink:}

It will also read straight from/to a filename and completely parse a config
file without you *having* to supply a config spec.

Uses listparse, so can handle nested list items as values.

No longer has getval and setval methods: use normal dictionary methods, or add
and delete.

2004/01/29 - Version 1.0.5
--------------------------

Version 1.0.5 has a couple of bugfixes as well as a couple of useful additions
over previous versions.

Since 1.0.0 the buildconfig function has been moved into this distribution,
and the methods reset, verify, getval and setval have been added.

A couple of bugs have been fixed.

Origins
-------

ConfigObj originated in a set of functions for reading config files in the
atlantibots_ project. The original functions were written by Rob McNeur...

.. _atlantibots: http://www.voidspace.org.uk/atlantibots

----------

Footnotes
=========

.. [#] The core parser is now based on regular expressions, so it's a lot
    faster.

.. [#] 134 of them, at the time of writing.

.. [#] And if you discover any bugs, let us know. We'll fix them quickly.

.. [#] If you specify a filename that doesn't exist, ConfigObj will assume you
    are creating a new one. See the *create_empty* and *file_error* options_.

.. [#] They can be byte strings ('ordinary' strings) or Unicode. If they are
    Unicode then ConfigObj will have to do an implicit encode before writing.
    See the encodings_ section for more details.

.. [#] Except we don't support the RFC822 style line continuations, nor ':' as
    a divider.

.. [#] For a file object that will depend what mode it was opened with. You
    can read *and* write to a ``StringIO`` instance, but not always to a
    ``cStringIO`` instance.

.. [#] A side effect of this is that it enables you to copy a ConfigObj :

.. raw:: html

    {+coloring}

    # only copies members
    # not attributes/comments
    config2 = ConfigObj(config1)

    {-coloring}

..

    The order of values and sections will not be preserved, though.

.. [#] Other than lists of strings.

.. [#] The method signature in the API docs will show that it does in fact
    take one argument: the section to be written. This is because the
    ``write`` method is called recursively. Using this argument *forces* write
    to return a list of lines, so it's probably not very useful to you.

.. [#] The dict method doesn't actually use the deepcopy mechanism. This means
    if you add nested lists (etc) to your ConfigObj, then the dictionary
    returned by dict may contain some references. For all *normal* ConfigObjs
    it will return a deepcopy.

.. [#] Passing ``(section, key)`` rather than ``(value, key)`` allows you to
    change the value by setting ``section[key] = newval``. It also gives you
    access to the *rename* method of the section.

.. [#] A current bug in unquoting when ``list_values=False`` currently makes
    this impossible. We are considering the best way to fix this.

.. [#] Minimum required version of *validate.py* 0.2.0 .

.. [#] There's nothing to stop you decoding the whole config file to Unicode
    *first*.

.. [#] It also makes ConfigObj a lot simpler to *use*.

.. note::

    Rendering this document with docutils also needs the
    textmacros module and the PySrc CSS stuff. See
    http://www.voidspace.org.uk/python/firedrop2/textmacros.shtml

.. raw:: html

    <div align="center">
        <a href="http://sourceforge.net/donate/index.php?group_id=123265">
            <img src="http://images.sourceforge.net/images/project-support.jpg" width="88" height="32" border="0" alt="Support This Project" /> 
        </a>
        <a href="http://sourceforge.net">
            <img src="http://sourceforge.net/sflogo.php?group_id=123265&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" />
        </a>
        <br />
        <a href="http://www.python.org">
            <img src="images/powered_by_python.jpg" width="602" height="186" border="0" />
        </a>
        <a href="http://www.opensource.org">
            <img src="images/osi-certified-120x100.gif" width="120" height="100" border="0" />
            <br /><strong>Certified Open Source</strong>
        </a>
        <br /><br />
        <script type="text/javascript" language="JavaScript">var site="s16atlantibots"</script>
        <script type="text/javascript" language="JavaScript1.2" src="http://s16.sitemeter.com/js/counter.js?site=s16atlantibots"></script>
        <noscript>
            <a href="http://s16.sitemeter.com/stats.asp?site=s16atlantibots">
                <img src="http://s16.sitemeter.com/meter.asp?site=s16atlantibots" alt="Site Meter" border=0 />
            </a>
        </noscript>
        <br />
    </div>

.. _listquote: http://www.voidspace.org.uk/python/modules.shtml#listquote
.. _Michael Foord: http://www.voidspace.org.uk
.. _Nicola Larosa: http://www.teknico.net
.. _Mark Andrews: http://www.la-la.com
