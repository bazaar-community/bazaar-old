============================
Guidelines for modifying bzr
============================

.. contents::

(The current version of this document is available in the file ``HACKING``
in the source tree, or at http://bazaar-ng.org/hacking.html)

Overall
=======

* New functionality should have test cases.  Preferably write the
  test before writing the code.

  In general, you can test at either the command-line level or the
  internal API level.  See Writing Tests below for more detail.

* Try to practice Test-Driven Development.  before fixing a bug, write a
  test case so that it does not regress.  Similarly for adding a new
  feature: write a test case for a small version of the new feature before
  starting on the code itself.  Check the test fails on the old code, then
  add the feature or fix and check it passes.

* Exceptions should be defined inside bzrlib.errors, so that we can
  see the whole tree at a glance.

* Imports should be done at the top-level of the file, unless there is
  a strong reason to have them lazily loaded when a particular
  function runs.  Import statements have a cost, so try to make sure
  they don't run inside hot functions.

* Module names should always be given fully-qualified,
  i.e. ``bzrlib.hashcache`` not just ``hashcache``.

* Commands should return non-zero when they encounter circumstances that
  the user should really pay attention to - which includes trivial shell
  pipelines.

  Recommended values are 
    0- OK, 
    1- Conflicts in merge-like operations, or changes are present in
       diff-like operations. 
    2- Unrepresentable diff changes (i.e. binary files that we cannot show 
       a diff of).
    3- An error or exception has occurred.

Evolving interfaces
-------------------

We have a commitment to 6 months API stability - any supported symbol in a
release of bzr MUST NOT be altered in any way that would result in
breaking existing code that uses it. That means that method names,
parameter ordering, parameter names, variable and attribute names etc must
not be changed without leaving a 'deprecated forwarder' behind. This even
applies to modules and classes.

If you wish to change the behaviour of a supported API in an incompatible
way, you need to change its name as well. For instance, if I add a optional keyword
parameter to branch.commit - that's fine. On the other hand, if I add a
keyword parameter to branch.commit which is a *required* transaction
object, I should rename the API - i.e. to 'branch.commit_transaction'. 

When renaming such supported API's, be sure to leave a deprecated_method (or
_function or ...) behind which forwards to the new API. See the
bzrlib.symbol_versioning module for decorators that take care of the
details for you - such as updating the docstring, and issuing a warning
when the old api is used.

For unsupported API's, it does not hurt to follow this discipline, but its
not required. Minimally though, please try to rename things so that
callers will at least get an AttributeError rather than weird results.


Standard parameter types
------------------------

There are some common requirements in the library: some parameters need to be
unicode safe, some need byte strings, and so on. At the moment we have
only codified one specific pattern: Parameters that need to be unicode
should be check via 'bzrlib.osutils.safe_unicode'. This will coerce the
input into unicode in a consistent fashion, allowing trivial strings to be
used for programmer convenience, but not performing unpredictably in the
presence of different locales.

Documentation
=============

If you change the behaviour of a command, please update its docstring
in bzrlib/commands.py.  This is displayed by the 'bzr help' command.

NEWS file
---------

If you make a user-visible change, please add a note to the NEWS file.
The description should be written to make sense to someone who's just
a user of bzr, not a developer: new functions or classes shouldn't be
mentioned, but new commands, changes in behaviour or fixed nontrivial
bugs should be listed.  See the existing entries for an idea of what
should be done.

Within each release, entries in the news file should have the most
user-visible changes first.  So the order should be approximately:

 * changes to existing behaviour - the highest priority because the 
   user's existing knowledge is incorrect
 * new features - should be brought to their attention
 * bug fixes - may be of interest if the bug was affecting them, and
   should include the bug number if any
 * major documentation changes
 * changes to internal interfaces

People who made significant contributions to each change are listed in
parenthesis.  This can include reporting bugs (particularly with good
details or reproduction recipes), submitting patches, etc.

API documentation
-----------------

Functions, methods, classes and modules should have docstrings
describing how they are used. 

The first line of the docstring should be a self-contained sentence.

For the special case of Command classes, this acts as the user-visible
documentation shown by the help command.

The docstrings should be formatted as reStructuredText_ (like this
document), suitable for processing using the epydoc_ tool into HTML
documentation.

.. _reStructuredText: http://docutils.sourceforge.net/rst.html
.. _epydoc: http://epydoc.sourceforge.net/



Coding style
============

Please write PEP-8__ compliant code.  

One often-missed requirement is that the first line of docstrings
should be a self-contained one-sentence summary.

__ http://www.python.org/peps/pep-0008.html



Naming
------

Functions, methods or members that are in some sense "private" are given
a leading underscore prefix.  This is just a hint that code outside the
implementation should probably not use that interface.

We prefer class names to be concatenated capital words (``TestCase``)
and variables, methods and functions to be lowercase words joined by
underscores (``revision_id``, ``get_revision``).

For the purposes of naming some names are treated as single compound
words: "filename", "revno".

Consider naming classes as nouns and functions/methods as verbs.


Standard names
--------------

``revision_id`` not ``rev_id`` or ``revid``

Functions that transform one thing to another should be named ``x_to_y``
(not ``x2y`` as occurs in some old code.)


Destructors
-----------

Python destructors (``__del__``) work differently to those of other
languages.  In particular, bear in mind that destructors may be called
immediately when the object apparently becomes unreferenced, or at some
later time, or possibly never at all.  Therefore we have restrictions on
what can be done inside them.

 0. Never use a __del__ method without asking Martin/Robert first.

 1. Never rely on a ``__del__`` method running.  If there is code that
    must run, do it from a ``finally`` block instead.

 2. Never ``import`` from inside a ``__del__`` method, or you may crash the
    interpreter!!

 3. In some places we raise a warning from the destructor if the object
    has not been cleaned up or closed.  This is considered OK: the warning
    may not catch every case but it's still useful sometimes.


Factories
---------

In some places we have variables which point to callables that construct
new instances.  That is to say, they can be used a lot like class objects,
but they shouldn't be *named* like classes:

> I think that things named FooBar should create instances of FooBar when
> called. Its plain confusing for them to do otherwise. When we have
> something that is going to be used as a class - that is, checked for via
> isinstance or other such idioms, them I would call it foo_class, so that
> it is clear that a callable is not sufficient. If it is only used as a
> factory, then yes, foo_factory is what I would use.


Writing output
==============

(The strategy described here is what we want to get to, but it's not
consistently followed in the code at the moment.)

bzrlib is intended to be a generically reusable library.  It shouldn't
write messages to stdout or stderr, because some programs that use it
might want to display that information through a GUI or some other
mechanism.

We can distinguish two types of output from the library:

 1. Structured data representing the progress or result of an
    operation.  For example, for a commit command this will be a list
    of the modified files and the finally committed revision number
    and id.

    These should be exposed either through the return code or by calls
    to a callback parameter.

    A special case of this is progress indicators for long-lived
    operations, where the caller should pass a ProgressBar object.

 2. Unstructured log/debug messages, mostly for the benefit of the
    developers or users trying to debug problems.  This should always
    be sent through ``bzrlib.trace`` and Python ``logging``, so that
    it can be redirected by the client.

The distinction between the two is a bit subjective, but in general if
there is any chance that a library would want to see something as
structured data, we should make it so.

The policy about how output is presented in the text-mode client
should be only in the command-line tool.


Writing tests
=============
In general tests should be placed in a file named test_FOO.py where 
FOO is the logical thing under test. That file should be placed in the
tests subdirectory under the package being tested.

For example, tests for merge3 in bzrlib belong in bzrlib/tests/test_merge3.py.
See bzrlib/selftest/test_sampler.py for a template test script.

Tests can be written for the UI or for individual areas of the library.
Choose whichever is appropriate: if adding a new command, or a new command 
option, then you should be writing a UI test.  If you are both adding UI
functionality and library functionality, you will want to write tests for 
both the UI and the core behaviours.  We call UI tests 'blackbox' tests
and they are found in bzrlib/tests/blackbox/*.py. 

When writing blackbox tests please honour the following conventions:

 1. Place the tests for the command 'name' in
    bzrlib/tests/blackbox/test_name.py. This makes it easy for developers
    to locate the test script for a faulty command.

 2. Use the 'self.run_bzr("name")' utility function to invoke the command
    rather than running bzr in a subprocess or invoking the
    cmd_object.run() method directly. This is a lot faster than
    subprocesses and generates the same logging output as running it in a
    subprocess (which invoking the method directly does not).
 
 3. Only test the one command in a single test script. Use the bzrlib 
    library when setting up tests and when evaluating the side-effects of
    the command. We do this so that the library api has continual pressure
    on it to be as functional as the command line in a simple manner, and
    to isolate knock-on effects throughout the blackbox test suite when a
    command changes it name or signature. Ideally only the tests for a
    given command are affected when a given command is changed.

Running tests
=============
Currently, bzr selftest is used to invoke tests.
You can provide a pattern argument to run a subset. For example, 
to run just the blackbox tests, run::

  ./bzr selftest -v blackbox


Errors and exceptions
=====================

Errors are handled through Python exceptions.  They can represent user
errors, environmental errors or program bugs.  Sometimes we can't be sure
at the time it's raised which case applies.  See bzrlib/errors.py for 
details on the error-handling practices.


Jargon
======

revno
    Integer identifier for a revision on the main line of a branch.
    Revision 0 is always the null revision; others are 1-based
    indexes into the branch's revision history.


Transport
=========

The ``Transport`` layer handles access to local or remote directories.
Each Transport object acts like a logical connection to a particular
directory, and it allows various operations on files within it.  You can
*clone* a transport to get a new Transport connected to a subdirectory or
parent directory.

Transports are not used for access to the working tree.  At present
working trees are always local and they are accessed through the regular
Python file io mechanisms.

filenames vs URLs
-----------------

Transports work in URLs.  Take note that URLs are by definition only
ASCII - the decision of how to encode a Unicode string into a URL must be
taken at a higher level, typically in the Store.  (Note that Stores also
escape filenames which cannot be safely stored on all filesystems, but
this is a different level.)

The main reason for this is that it's not possible to safely roundtrip a
URL into Unicode and then back into the same URL.  The URL standard
gives a way to represent non-ASCII bytes in ASCII (as %-escapes), but
doesn't say how those bytes represent non-ASCII characters.  (They're not
guaranteed to be UTF-8 -- that is common but doesn't happen everywhere.)

For example if the user enters the url ``http://example/%e0`` there's no
way to tell whether that character represents "latin small letter a with
grave" in iso-8859-1, or "latin small letter r with acute" in iso-8859-2
or malformed UTF-8.  So we can't convert their URL to Unicode reliably.

Equally problematic if we're given a url-like string containing non-ascii
characters (such as the accented a) we can't be sure how to convert that
to the correct URL, because we don't know what encoding the server expects
for those characters.  (Although this is not totally reliable we might still
accept these and assume they should be put into UTF-8.)

A similar edge case is that the url ``http://foo/sweet%2Fsour" contains
one directory component whose name is "sweet/sour".  The escaped slash is
not a directory separator.  If we try to convert URLs to regular Unicode
paths this information will be lost.

This implies that Transports must natively deal with URLs; for simplicity
they *only* deal with URLs and conversion of other strings to URLs is done
elsewhere.  Information they return, such as from ``list_dir``, is also in
the form of URL components.


Merge/review process
====================

If you'd like to propose a change, please post to the
bazaar-ng@lists.canonical.com list with a patch, bzr changeset, or link to a
branch.  Please put '[patch]' in the subject so we can pick them out, and
include some text explaining the change.  Remember to put an update to the NEWS
file in your diff, if it makes any changes visible to users or plugin
developers.  Please include a diff against mainline if you're giving a link to
a branch.

Please indicate if you think the code is ready to merge, or if it's just a
draft or for discussion.  If you want comments from many developers rather than
to be merged, you can put '[rfc]' in the subject lines.

Anyone is welcome to review code.  There are broadly three gates for
code to get in:

 * Doesn't reduce test coverage: if it adds new methods or commands,
   there should be tests for them.  There is a good test framework
   and plenty of examples to crib from, but if you are having trouble
   working out how to test something feel free to post a draft patch
   and ask for help.

 * Doesn't reduce design clarity, such as by entangling objects
   we're trying to separate.  This is mostly something the more
   experienced reviewers need to help check.

 * Improves bugs, features, speed, or code simplicity.

Code that goes in should pass all three.

If you read a patch please reply and say so.  We can use a numeric scale
of -1, -0, +0, +1, meaning respectively "really don't want it in current
form", "somewhat uncomfortable", "ok with me", and "please put it in".
Anyone can "vote".   (It's not really voting, just a terse expression.)

If something gets say two +1 votes from core reviewers, and no
vetos, then it's OK to come in.  Any of the core developers can bring it
into their integration branch, which I'll merge regularly.  (If you do
so, please reply and say so.)


:: vim:tw=74:ai
