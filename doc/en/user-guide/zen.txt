Bazaar Zen
==========

Grokking Bazaar
---------------

While Bazaar is similar to other VCS tools in many ways, there are
some important differences that are not necessarily obvious at first
glance. These differences are there for a reason: Bazaar's designers
want to encourage users to work in particular ways. This section attempts
to explain some of the things users need to know in order to "grok" Bazaar,
i.e. to deeply understand it.

Note: It isn't necessary to fully understand this section to use Bazaar.
You may wish to skim this section now and come back to it at a later time.

Understanding revision numbers
------------------------------

All revisions in the mainline of a branch will have a simple increasing
integer. (First commit gets 1, 10th commit gets 10, etc.) This makes them
fairly natural to use when you want to say "grab the 10th revision from my
branch", or "fixed in revision 3050".

For revisions which have been merged into a branch, a dotted notation is
used (eg, 3112.1.5). Dotted revision numbers have three numbers. The first
number indicates what mainline revision change is derived from. The second
number is the branch counter. There can be many branches derived from the
same revision, so they all get a unique number. The third number is the
number of revisions since the branch started. For example, 3112.1.5 is the
first branch from revision 3112, the fifth revision on that branch.

Note: Versions prior to bzr 1.2 used a slightly different algorithm.
Some nested branches would get extra numbers (such as 1.1.1.1.1)
rather than the simpler 3-number system.

Hierarchical history is good
----------------------------

Imagine a project with multiple developers contributing changes where
many changes consist of a series of commits. To give a concrete example,
consider the case where:

 * The tip of the project's mainline is revision 100.
 * Mary makes 3 changes to deliver feature X.
 * Bill makes 4 changes to deliver feature Y.

If the developers are working in parallel and using a traditional
centralized VCS approach, the project history will most likely be linear
with Mary's changes and Bill's changes interleaved. It might look like this::

  107: Add documentation for Y
  106: Fix bug found in testing Y
  105: Fix bug found in testing X
  104: Add code for Y
  103: Add documentation for X
  102: Add code and tests for X
  101: Add tests for Y
  100: ...
  
Many teams use this approach because their tools make branching and merging
difficult. As a consequence, developers update from and commit to the mainline
frequently, minimizing integration pain by spreading it over every commit.

An alternative approach encouraged by distributed VCS tools is to create
feature branches and to integrate those when they are ready. In this case,
Mary's feature branch would look like this::

  103: Fix bug found in testing X
  102: Add documentation for X
  101: Add code and tests for X
  100: ...

And Bill's would look like this::

  104: Add documentation for Y
  103: Fix bug found in testing Y
  102: Add code for Y
  101: Add tests for Y
  100: ...

If the features were independent, one way to integrate those changes back into
the mainline is to *push* from each feature branch. The resulting history might
look like this::

  107: Fix bug found in testing X
  106: Add documentation for X
  105: Add code and tests for X
  104: Add documentation for Y
  103: Fix bug found in testing Y
  102: Add code for Y
  101: Add tests for Y
  100: ...

Bazaar's preferred way though is to use *merge* instead of *push*. The
resulting history might look like this::

  102: Merge feature X
       100.2.3: Fix bug found in testing X
       100.2.2: Add documentation for X
       100.2.1: Add code and tests for X
  101: Merge feature Y
       100.1.4: Add documentation for Y
       100.1.3: Fix bug found in testing Y
       100.1.2: Add code for Y
       100.1.1: Add tests for Y
  100: ...

Or more likely this::

  102: Merge feature X
       100.2.3: Fix bug
       100.2.2: Add documentation
       100.2.1: Add code and tests
  101: Merge feature Y
       100.1.4: Add documentation
       100.1.3: Fix bug found in testing
       100.1.2: Add code
       100.1.1: Add tests
  100: ...

This is considered good for many reasons:

 * It makes it easier to understand the history of a project.
   Related changes are clustered together and clearly partitioned.

 * You can use ``bzr log --short`` to see just the top level commits.
   When viewing the mainline like this, you only see high level commits
   (instead of a large number of commits uninteresting at this level).

 * If you have a large project with developers working on sub-teams,
   you can give each team an integration branch and adopt a policy
   where only integration branches get merged into the mainline.
   This cascading hierarchy (project-team-change in this case)
   will be shown correctly when viewing history.

 * If required, it makes backing out a feature much easier.

 * Continuous integration tools can be used to ensure that
   all tests still pass before committing a merge to the mainline.
   (In many cases, it isn't appropriate to trigger CI tools after
   every single commit as some tests will fail during development.
   In fact, adding the tests first - TDD style - will guarantee it!)

In summary, the important point is this:

  *Use merge+commit to integrate; use push and pull to mirror.*

Each branch has its own view of history
---------------------------------------

As explained above, Bazaar makes the distinction between top-level
revisions (ones you committed in your branch) and merged
revisions (ones added as ancestors by committing a merge). Each
branch effectively has its own "view" of history, i.e. different
branches can give the same revision a different "local revision number".

To extend the example above, here's what the revision history of
Mary's branch would look like had she decided to merge the project
mainline into her branch (and commit that merge) after completing it::

  104: Merge mainline
       100.2.1: Merge feature Y
       100.1.4: Add documentation
       100.1.3: Fix bug found in testing
       100.1.2: Add code
       100.1.1: Add tests
  103: Fix bug found in testing X
  102: Add documentation for X
  101: Add code and tests for X
  100: ...

It's important to remember that Bazaar is not changing history here, nor
is it changing the global revision identifiers. You can always use the
latter if you really want to. In fact, you can use the branch specific
revision numbers when communicating as long as you provide the branch
URL as context.

Revisions are numbered in a stable way, such that if two branches have the
same revision in their mainline, all revisions in the ancestry of that
revision will have the same revision numbers. (So if Alice and Bob's
branches agree on revision 10, they will agree on all revisions before
that.) Future merges will not change revision numbers. However doing
``bzr pull`` can change revision numbers, because it changes the
mainline revisions.

..
   vim: ft=rst tw=74 ai
