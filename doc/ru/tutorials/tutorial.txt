.. Этот файл в формате ReStructuredText - он может быть отформатирован в HTML,
.. или текст. В будущем планируется выделять примеры команд и автоматически
.. тестировать их.

.. Данный текст сначала был на Wiki
.. http://bazaar.canonical.com/IntroductionToBzr
.. но был перемещен в дерево исходного кода что бы синхронизироваться
.. с исходным кодом и возможно автоматически тестироваться.

==============
Учебник Bazaar
==============

Текущая версия для bzr-0.91, 2007-08


Введение
========

Если вы уже знакомы с распределенными системами контроля версий, то можете
сразу перейти к "Представляем себя Bazaar". Если, с другой стороны, вы знакомы
с системами контроля версий, но не знакомы с распределенными системами, тогда
стоит начать с "Чем отличаются распределенные системы". Иначе, возьмите кофе
или чай, расположитесь поудобнее и продолжим чтение.

Назначение контроля версий
==========================

Есть шансы, что вы уже работали с какими-либо текстовыми данными -- исходниками
программ, Web-сайтами, или конфигурационными файлами с которыми имеют дело
администраторы систем Unix в /etc. Так же есть хорошие шансы, что вы делали
ошибки, которые вызывали потом глубокое сожаление. Возможно вы удалили
конфигурационный файл для вашего почтового сервера, или повредили исходный код
любимого проекта. Не важно что конкретно случилось, но вы просто удалили важную
информацию которую вы безнадежно хотели бы вернуть. Если такое когда либо
случалось с вами, то вы возможно готовы для Bazaar.

Системы контроля версий, такие как Bazaar дают возможность отслеживать
изменения для директории, которую они изменяют в нечто более сложное, что
называется **ветка**. Ветка не только сохраняет как директория выглядит в
данный момент, но также как она выглядела в различные моменты в прошлом. Затем,
когда вы сделаете что-то, что бы вы не хотели делать, вы сможете восстановить
директорию в том виде как она выглядела в какой-то момент в прошлом.

Системы контроля версий дают пользователям возможность сохранять изменения на
ветке "фиксируя **ревизию**". Созданная ревизия фактически является сводкой
изменений, которые были сделаны с последнего момента когда дерево было
сохранено.

Эти ревизии имеют также и другое назначение. Например, можно комментировать
ревизии, записав, что значит данный набор изменений, через необязательную
запись в журнале. Реальные записи в журнале могут быть похожи на "Исправлен
Web-шаблон для закрытия таблицы" и "Добавлена поддержка SFTP. Исправлен #595"

Мы храним этот журнал, что бы позже, в случае каких-либо проблем с SFTP, можно
было определить когда могла произойти проблема.

Чем отличаются распределенные системы
-------------------------------------

Многие системы контроля версий хранят данные на серверах. Если кто-то хочет
работать с кодом, который хранится в системе тогда ему нужно установить
соединение с сервером и "создать рабочую копию" кода. При этом создается
директорий в котором можно менять файлы и затем фиксировать изменения. Клиент
системы затем соединяется с сервером системы и сохраняет изменения. Этот метод
известен как централизованная модель.

Централизованная модель может иметь некоторые недостатки. Централизованная
система требует наличия соединения с сервером для любых действий по контролю
версий. Это может быть проблематичным если сервер находится на другой машине в
интернете, а клиент - нет. Или, хуже, клиент **в** интернете, а сервер - нет.

Распределенные системы контроля версий обходят эту проблему сохраняя ветки на
той же машине на которой находится клиент. В случае с Bazaar, ветка находится в
том же самом месте, что и код хранящийся под контролем версий. Это позволяет
пользователю сохранять (**фиксировать**) изменения когда он захочет -- даже без
сетевого подключения. Пользователю нужен доступ к интернету только когда он
хочет получить доступ к чьей-либо ветке в другом месте.

Общее требование, что многие люди хотят отслеживать изменения для директории,
такие как изменения файлов и изменения в поддиректориях. Отслеживать это
"руками" ужасный процесс, который со временем становится громоздким. До тех пор
пока вы не попробуете систему контроля версий, такую как Bazaar. Такие
инструменты автоматизируют процесс сохранения данных создавая **ревизии**
дерева директории когда пользователь запрашивает сделать это.

Системы контроля версий, такие как Bazaar, могут делать намного больше чем
просто хранить изменения и отменять ошибочные действия. Например, с помощью
Bazaar разработчики могут взять изменения кода на одной ветке и объединить их
со связанной веткой -- даже если эти изменения хранятся на ветке которую создал
кто-то другой. Это позволяет разработчикам сотрудничать без необходимости
открывать доступ на запись к репозиторию.

Bazaar помнит ''предков'' ревизии: предыдущие ревизии на которых основана
текущая ревизия. Одна ревизия может иметь больше одного прямого потомка, каждый
из которых со своими изменениями, что представляет дивергенцию в эволюции
дерева. Создание веток в Bazaar позволяет нескольким людям сотрудничать в
эволюции проекта, без необходимости работать жестко по шагам. Создание веток
может быть полезным даже для одного разработчика.

Представляем себя Bazaar
========================

Bazaar устанавливает единственную новую команду, **bzr**. Все возможности
предоставляются через под-команды этой команды. Вы можете просмотреть краткую
справку командой ``bzr help``. Некоторые идеи группируются по темам,
используйте ``bzr help topics`` для списка доступных тем.

Одна из функций системы контроля версий -- отслеживать кто сделал изменения. В
распределенных системах для этого требуется идентифицировать каждого автора
уникально в глобальном плане. Большинство людей уже имеют такой идентификатор:
email адрес. Bazaar достаточно умен, что бы автоматически создавать email адрес
из текущего имени и адреса хоста. Если вам не нравится предположение которое
делает Bazaar вы сможете выбрать из трех опций:

 #. Установить email адрес через ``bzr whoami``. Это наиболее простой путь.

    Что бы установить такой глобальный идентификатор, используйте::

     % bzr whoami "Ваше Имя <email@example.com>"

    Если вы хотите использовать разные адреса для разных веток, то зайдите
    в директорию с веткой и используйте::

     % bzr whoami --branch "Ваше Имя <email@example.com>"

 #. Установить email адрес в ``~/.bazaar/bazaar.conf`` [1]_, добавив следующие
    строчки. Заметьте, что ``[DEFAULT]`` зависит от регистра символов::

        [DEFAULT]
        email=Ваше Имя <email@isp.com>

    Как и выше вы можете переопределить эти установки для каждой ветки
    создав секцию для ветки в ``~/.bazaar/locations.conf`` и добавив
    следующие строчки::

        [/путь/к/ветке]
        email=Ваше Имя <email@isp.com>

 #. Переопределить два предыдущих способа, установив ваш полный email адрес в
    глобальную переменную среды ``$BZR_EMAIL``, или ``$EMAIL`` (``$BZR_EMAIL``
    имеет больший приоритет).

.. [1] Для Windows пользовательские файлы конфигурации могут быть найдены в
   директории с данными приложений. Таким образом вместо
   ``~/.bazaar/branch.conf`` конфигурация может быть найдена в:
   ``C:\Documents and Settings\<пользователь>\Application Data\Bazaar\2.0\branch.conf``. Там же могут
   быть найдены ``locations.conf``, ``ignore`` и директория ``plugins``.

Создаем ветку
=============

История по-умолчанию хранится на ветке в директории .bzr. В будущих версиях
Bazaar будут средства для хранения истории в отдельном репозитории, который
также сможет быть удаленным.

Мы создаем новую ветку выполнив ``bzr init`` в уже созданной директории::

    % mkdir tutorial
    % cd tutorial
    % ls -a
    ./  ../
    % pwd
    /home/mbp/work/bzr.test/tutorial
    %
    % bzr init
    % ls -aF
    ./  ../  .bzr/
    %

Как и в CVS здесь три класса файлов: неизвестные, игнорируемые и под контролем
версий. Команда **add** ставит файл под контроль версий, т.е. изменения в нем
будут записываться системой::

    % echo 'hello world' > hello.txt
    % bzr status
    unknown:
      hello.txt
    % bzr add hello.txt
    added hello.txt
    % bzr status
    added:
      hello.txt

Если вы добавили не тот файл просто сделайте ``bzr remove``, что бы сделать его
опять неизвестным. Рабочая копия файла не будет удалена в этом случае, хотя она
может быть удалена в других случаях [2]_.

.. [2] ``bzr remove`` удалит рабочую копию если она находится под контролем
   версий, но не имеет изменений с последней зафиксированной версии. Вы
   можете оставить файл указав опцию ``--keep`` для ``bzr remove``, или
   удалить с опцией ``--force``.

Размещение веток
================

Вся история хранится на ветке, которая является всего лишь директорией на диске
содержащей файлы управления. По-умолчанию здесь нет отдельного репозитория, или
базы данных как в svn, или svk. По желанию вы можете создать репозиторий (см.
команду ``bzr init-repo``). Это можно сделать в случае очень больших веток, или
большого количества веток для проекта среднего размера.

Мы обычно обращаемся к веткам на нашем компьютере просто передав имя директории
содержащей ветку. bzr также поддерживает доступ к веткам через http и sftp,
например::

    % bzr log http://bazaar-vcs.org/bzr/bzr.dev/
    % bzr log sftp://bazaar-vcs.org/bzr/bzr.dev/

Установив для bzr плагины можно также осуществлять доступ к веткам с
использованием rsync.

Смотрите секцию `Публикация ветки`_ что бы получить больше информации о том как
поместить свою ветку в нужное место.

Reviewing changes
=================

Once you have completed some work, you will want to **commit** it to the
version history.  It is good to commit fairly often: whenever you get a
new feature working, fix a bug, or improve some code or documentation.
It's also a good practice to make sure that the code compiles and passes
its test suite before committing, to make sure that every revision is a
known-good state.  You can also review your changes, to make sure you're
committing what you intend to, and as a chance to rethink your work before
you permanently record it. 

Two bzr commands are particularly useful here: **status** and **diff**.  

bzr status
----------

The **status** command tells you what changes have been made to the
working directory since the last revision::

    % bzr status
    modified:
       foo

``bzr status`` hides "boring" files that are either unchanged or ignored.
The status command can optionally be given the name of some files or
directories to check.

bzr diff
--------

The **diff** command shows the full text of changes to all files as a
standard unified diff.  This can be piped through many programs such as
''patch'', ''diffstat'', ''filterdiff'' and ''colordiff''::

    % bzr diff
    === added file 'hello.txt'
    --- hello.txt   1970-01-01 00:00:00 +0000
    +++ hello.txt   2005-10-18 14:23:29 +0000
    @@ -0,0 +1,1 @@
    +hello world


With the ``-r`` option, the tree is compared to an earlier revision, or
the differences between two versions are shown::

    % bzr diff -r 1000..          # everything since r1000
    % bzr diff -r 1000..1100      # changes from 1000 to 1100

The ``--diff-options`` option causes bzr to run the external diff program,
passing options.  For example::

    % bzr diff --diff-options --side-by-side foo

Some projects prefer patches to show a prefix at the start of the path
for old and new files.  The ``--prefix`` option can be used to provide
such a prefix.
As a shortcut, ``bzr diff -p1`` produces a form that works with the 
command ``patch -p1``.

Committing changes
==================

When the working tree state is satisfactory, it can be **committed** to
the branch, creating a new revision holding a snapshot of that state.  

bzr commit
----------

The **commit** command takes a message describing the changes in the
revision.  It also records your userid, the current time and timezone, and
the inventory and contents of the tree.  The commit message is specified
by the ``-m`` or ``--message`` option. You can enter a multi-line commit
message; in most shells you can enter this just by leaving the quotes open
at the end of the line.

::

    % bzr commit -m "added my first file"

You can also use the ``-F`` option to take the message from a file.  Some
people like to make notes for a commit message while they work, then
review the diff to make sure they did what they said they did.  (This file
can also be useful when you pick up your work after a break.)

Message from an editor
======================

If you use neither the ``-m`` nor the ``-F`` option then bzr will open an
editor for you to enter a message.  The editor to run is controlled by
your ``$VISUAL`` or ``$EDITOR`` environment variable, which can be overridden
by the ``editor`` setting in ``~/.bazaar/bazaar.conf``; ``$BZR_EDITOR`` will
override either of the above mentioned editor options.  If you quit the
editor without making any changes, the commit will be cancelled.

The file that is opened in the editor contains a horizontal line. The part
of the file below this line is included for information only, and will not
form part of the commit message. Below the separator is shown the list of
files that are changed in the commit. You should write your message above
the line, and then save the file and exit.

If you would like to see the diff that will be committed as you edit the
message you can use the ``--show-diff`` option to ``commit``. This will include
the diff in the editor when it is opened, below the separator and the
information about the files that will be committed. This means that you can
read it as you write the message, but the diff itself wont be seen in the
commit message when you have finished. If you would like parts to be
included in the message you can copy and paste them above the separator.

Selective commit
----------------

If you give file or directory names on the commit command line then only
the changes to those files will be committed.  For example::

    % bzr commit -m "documentation fix" commit.py

By default bzr always commits all changes to the tree, even if run from a
subdirectory.  To commit from only the current directory down, use::

    % bzr commit .


Removing uncommitted changes
============================

If you've made some changes and don't want to keep them, use the
**revert** command to go back to the previous head version.  It's a good
idea to use ``bzr diff`` first to see what will be removed. By default the
revert command reverts the whole tree; if file or directory names are
given then only those ones will be affected. ``bzr revert`` also clears the
list of pending merges revisions.

Ignoring files
==============

Many source trees contain some files that do not need to be versioned,
such as editor backups, object or bytecode files, and built programs.  You
can simply not add them, but then they'll always crop up as unknown files.
You can also tell bzr to ignore these files by adding them to a file
called ``.bzrignore`` at the top of the tree.

This file contains a list of file wildcards (or "globs"), one per line.
Typical contents are like this::

    *.o
    *~
    *.tmp
    *.py[co]

If a glob contains a slash, it is matched against the whole path from the
top of the tree; otherwise it is matched against only the filename.  So
the previous example ignores files with extension ``.o`` in all
subdirectories, but this example ignores only ``config.h`` at the top level
and HTML files in ``doc/``::

    ./config.h
    doc/*.html

To get a list of which files are ignored and what pattern they matched,
use ``bzr ignored``::

    % bzr ignored
    config.h                 ./config.h
    configure.in~            *~

It is OK to have either an ignore pattern match a versioned file, or to
add an ignored file.  Ignore patterns have no effect on versioned files;
they only determine whether unversioned files are reported as unknown or
ignored.

The ``.bzrignore`` file should normally be versioned, so that new copies
of the branch see the same patterns::

    % bzr add .bzrignore
    % bzr commit -m "Add ignore patterns"


Global Ignores
--------------

There are some ignored files which are not project specific, but more user
specific. Things like editor temporary files, or personal temporary files.
Rather than add these ignores to every project, bzr supports a global
ignore file in ``~/.bazaar/ignore`` [1]_. It has the same syntax as the
per-project ignore file.


Examining history
=================

bzr log
-------

The ``bzr log`` command shows a list of previous revisions. The ``bzr log
--forward`` command does the same in chronological order to get most
recent revisions printed at last.

As with ``bzr diff``, ``bzr log`` supports the ``-r`` argument::

    % bzr log -r 1000..          # Revision 1000 and everything after it
    % bzr log -r ..1000          # Everything up to and including r1000
    % bzr log -r 1000..1100      # changes from 1000 to 1100
    % bzr log -r 1000            # The changes in only revision 1000


Branch statistics
=================

The ``bzr info`` command shows some summary information about the working
tree and the branch history.  


Versioning directories
======================

bzr versions files and directories in a way that can keep track of renames
and intelligently merge them::

    % mkdir src
    % echo 'int main() {}' > src/simple.c
    % bzr add src
    added src
    added src/simple.c
    % bzr status
    added:
      src/
      src/simple.c


Deleting and removing files
===========================

You can delete files or directories by just deleting them from the working
directory.  This is a bit different to CVS, which requires that you also
do ``cvs remove``.

    ``bzr remove`` makes the file un-versioned, but may or may not delete
    the working copy [2]_.  This is useful when you add the wrong file,
    or decide that a file should actually not be versioned. 

::

    % rm -r src
    % bzr remove -v hello.txt
    ?       hello.txt
    % bzr status
    removed:
      hello.txt
      src/
      src/simple.c
    unknown:
      hello.txt

If you remove the wrong file by accident, you can use ``bzr revert`` to
restore it.


Branching
=========

Often rather than starting your own project, you will want to submit a
change to an existing project.  To do this, you'll need to get a copy of
the existing branch.  Because this new copy is potentially a new branch,
the command is called **branch**::

    % bzr branch http://bazaar-vcs.org/bzr/bzr.dev 
    % cd bzr.dev

This copies down the complete history of this branch, so we can do all
operations on it locally: log, annotate, making and merging branches.
There will be an option to get only part of the history if you wish.

You can also get a copy of an existing branch by copying its directory,
expanding a tarball, or by a remote copy using something like rsync.

Following upstream changes
==========================

You can stay up-to-date with the parent branch by "pulling" in their
changes::

    % bzr pull

After this change, the local directory will be a mirror of the source. This
includes the ''revision-history'' - which is a list of the commits done in 
this branch, rather than merged from other branches.

This command only works if your local (destination) branch is either an
older copy of the parent branch with no new commits of its own, or if the
most recent commit in your local branch has been merged into the parent
branch.

Merging from related branches
=============================

If two branches have diverged (both have unique changes) then ``bzr
merge`` is the appropriate command to use. Merge will automatically
calculate the changes that exist in the branch you're merging from that
are not in your branch and attempt to apply them in your branch.

::

  % bzr merge URL


If there is a conflict during a merge, 3 files with the same basename
are created. The filename of the common base is appended with ".BASE",
the filename of the file containing your changes is appended with
".THIS" and the filename with the changes from the other tree is
appended with ".OTHER".  Using a program such as kdiff3, you can now
comfortably merge them into one file.  In order to commit you have to
rename the merged file (".THIS") to the original file name.  To
complete the conflict resolution you must use the resolve command,
which will remove the ".OTHER" and ".BASE" files.  As long as there
exist files with .BASE, .THIS or .OTHER the commit command will
report an error.

::

  % kdiff3 file.BASE file.OTHER file.THIS
  % mv file.THIS file
  % bzr resolve file

[**TODO**: explain conflict markers within files]


Публикация ветки
================

You don't need a special server to publish a bzr branch, just a normal web
server.  Just mirror the files to your server, including the .bzr
directory.  One can push a branch (or the changes for a branch) by one of
the following three methods:

* The best method is to use bzr itself to do it.

  ::

    % bzr push sftp://servername.com/path/to/directory 

  (The destination directory must already exist unless the
  ``--create-prefix`` option is used.)

* Another option is the ``rspush`` plugin that comes with BzrTools, which
  uses rsync to push the changes to the revision history and the working
  tree.

You can also use copy the files around manually, by sending a tarball, or
using rsync, or other related file transfer methods.  This is usually
less safe than using ``push``, but may be faster or easier in some
situations.

Moving changes between trees 
============================

It happens to the best of us: sometimes you'll make changes in the wrong
tree.  Maybe because you've accidentally started work in the wrong directory,
maybe because as you're working, the change turns out to be bigger than you
expected, so you start a new branch for it.

To move your changes from one tree to another, use

::

  % cd NEWDIR
  % bzr merge --uncommitted OLDDIR

This will apply all of the uncommitted changes you made in OLDDIR to NEWDIR.
It will not apply committed changes, even if they could be applied to NEWDIR
with a regular merge.  The changes will remain in OLDDIR, but you can use ``bzr
revert OLDDIR`` to remove them, once you're satisfied with NEWDIR.

NEWDIR does not have to be a copy of OLDDIR, but they should be related.
The more different they are, the greater the chance of conflicts.
