=== modified file 'bzrlib/weave.py'
--- bzrlib/weave.py
+++ bzrlib/weave.py
@@ -83,6 +83,10 @@
 
 # TODO: Perhaps the API should work only in names to hide the integer
 # indexes from the user?
+
+# TODO: Is there any potential performance win by having an add()
+# variant that is passed a pre-cooked version of the single basis
+# version?
 
 
 
@@ -191,8 +195,8 @@
         Set by read_weave.
     """
 
-    __slots__ = ['_weave', '_parents', '_sha1s', '_names', '_name_map',
-                 '_weave_name']
+    ##__slots__ = ['_weave', '_parents', '_sha1s', '_names', '_name_map',
+    ##             '_weave_name', '_inclusion_cache']
     
     def __init__(self, weave_name=None):
         self._weave = []
@@ -201,7 +205,7 @@
         self._names = []
         self._name_map = {}
         self._weave_name = weave_name
-
+        self._inclusion_cache = {}
 
     def __eq__(self, other):
         if not isinstance(other, Weave):
@@ -300,7 +304,6 @@
                 self._weave.append(('{', new_version))
                 self._weave.extend(text)
                 self._weave.append(('}', None))
-        
             return new_version
 
         if len(parents) == 1:
@@ -308,10 +311,9 @@
             if sha1 == self._sha1s[pv]:
                 # special case: same as the single parent
                 return new_version
-            
 
         ancestors = self.inclusions(parents)
-
+        self._inclusion_cache[(new_version,)] = ancestors | set([new_version])
         l = self._weave
 
         # basis a list of (origin, lineno, line)
@@ -379,17 +381,19 @@
 
     def inclusions(self, versions):
         """Return set of all ancestors of given version(s)."""
+        tv = tuple(sorted(versions))
+        cached_val = self._inclusion_cache.get(tv)
+        if cached_val is not None:
+            return cached_val
         i = set(versions)
-        v = max(versions)
-        try:
-            while v >= 0:
-                if v in i:
-                    # include all its parents
-                    i.update(self._parents[v])
-                v -= 1
-            return i
-        except IndexError:
-            raise ValueError("version %d not present in weave" % v)
+        for v in xrange(max(versions), 0, -1):
+            if v in i:
+                # include all its parents
+                i.update(self._parents[v])
+        self._inclusion_cache[tv] = i
+        return i
+        ## except IndexError:
+        ##     raise ValueError("version %d not present in weave" % v)
 
 
     def parents(self, version):

